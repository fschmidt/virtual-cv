# Mission Specification: Virtual CV Monorepo — Multi-Agent Assessment & Improvement

You are a coordinated team of AI agents. Your mission: understand, audit, document, and incrementally improve the **virtual-cv** monorepo — an interactive, graph-based CV website that doubles as a portfolio project.

---

## 0. PRIME DIRECTIVE

**Read `/CLAUDE.md` before doing anything else.** It is the single authoritative source for domain context, conventions, constraints, architecture, and design intent. If anything in this prompt conflicts with `CLAUDE.md`, `CLAUDE.md` wins. Every agent must internalize its contents before beginning work.

Additionally, read `docs/initial-roadmap.md` as reference material — it describes the original vision and target architecture. **Do not modify it.** Use it to assess vision-vs-reality drift.

---

## 1. REPOSITORY FACTS

| Property | Value |
|----------|-------|
| **Structure** | Monorepo: `virtual-cv-ui/` (frontend), `virtual-cv-api/` (backend), `k8s/` (infrastructure), `docs/` (documentation) |
| **Frontend** | React 19, Vite 7, TypeScript 5.9, @xyflow/react 12, react-markdown, lucide-react |
| **Backend** | Java 21, Spring Boot 3.5.10, Spring Data JPA, PostgreSQL 16, Flyway, springdoc-openapi 2.8.6 |
| **API Contract** | OpenAPI 3.0 auto-generated by springdoc → consumed via Orval → `src/api/generated.ts` |
| **Infrastructure** | Kubernetes (k3s on Hetzner Cloud cx33), Docker, GitHub Container Registry |
| **CI/CD** | `deploy.yml` (frontend → GitHub Pages), `deploy-api.yml` (backend → Docker → K8s rollout) |
| **Testing** | Backend: JUnit 5 + Testcontainers (repository layer only, 4 test files). Frontend: **zero tests**. |
| **Frontend Linting** | ESLint with TypeScript + React hooks plugins. No Prettier. No formatter. |
| **Live URLs** | Frontend: `https://fschmidt.github.io/virtual-cv/` — API: `https://api.fschmidts.net` |

### Build & Run Commands

```bash
# Frontend
cd virtual-cv-ui
npm install                                          # install deps
npm run dev                                          # dev server at :5173
npm run build                                        # tsc + vite build (outputs to dist/)
npm run lint                                         # ESLint
npm run generate-api                                 # regenerate TS client from OpenAPI spec

# Backend
cd virtual-cv-api
docker compose up -d                                 # PostgreSQL at :5433
SPRING_PROFILES_ACTIVE=local ./gradlew bootRun       # API at :9823
./gradlew test                                       # tests (requires Docker for Testcontainers)
./gradlew build                                      # build JAR
```

### Untouchable Files

| File | Reason |
|------|--------|
| `virtual-cv-ui/src/api/generated.ts` | Auto-generated by Orval from OpenAPI spec. Regenerate via `npm run generate-api`, never edit manually. |
| `docs/initial-roadmap.md` | Historical reference document. Read-only. |

---

## 2. SHARED GLOSSARY

All agents must use these terms consistently. They are defined in `CLAUDE.md` and the codebase.

| Term | Definition |
|------|-----------|
| **Node** | A unit of CV content (profile, category, item, skill-group, skill). Backend entity: `CvNode`. Frontend types: `CVNode` and subtypes. |
| **Node state** | Visual rendering state on the graph canvas: `detailed` (selected, full content), `quickview` (circle with label, neighbor of selected), `dormant` (small dot, everything else). |
| **Node type** | `profile`, `category`, `item`, `skill-group`, `skill`. Determines schema and rendering. |
| **Inspector panel** | Side panel showing rich content for the selected node. Supports edit mode. |
| **Edit mode** | Feature-flagged mode (Ctrl+Shift+D) enabling CRUD operations on the graph. |
| **Draft/publish** | Workflow where nodes can be marked as drafts (dashed border, amber) before publishing. |
| **ContentMap** | `Record<string, string>` mapping node IDs to markdown content strings. |
| **CV_SECTIONS** | Predefined section identifiers for category nodes (work, skills, projects, education). |
| **Progressive disclosure** | Core UX principle: show overview first, reveal details on interaction. |

---

## 3. EXISTING DOCUMENTATION MAP

These documents exist. **Update them in place. Do not create parallel versions.**

| File | Current State | Update Strategy |
|------|--------------|-----------------|
| `CLAUDE.md` | Authoritative, well-maintained, ~164 lines | Extend with findings. Keep concise. Add sections; don't restructure what works. |
| `README.md` (root) | Stub — 2 lines: "# virtual-cv / My virtual cv" | **Rewrite fully.** Architecture overview, quick start, tech stack, links to sub-docs. |
| `docs/backlog.md` | Active backlog with completed phases and upcoming work | Append audit-driven items. Preserve existing priorities and structure. |
| `docs/initial-roadmap.md` | Original 6-phase vision document | **Read-only.** Reference for vision-vs-reality analysis. |
| `virtual-cv-api/README.md` | Good but has inaccuracies (says "soft delete" — code uses hard delete since V4 migration) | Fix inaccuracies. Verify endpoint table against actual controller. |
| `virtual-cv-ui/README.md` | Vite template boilerplate, not project-specific | **Rewrite** with component inventory, service layer docs, dev workflow. |
| `k8s/README.md` | Solid K8s deployment guide | Update only if infra findings warrant it. |

### New Documents (create only these)

| File | Purpose | Created By |
|------|---------|-----------|
| `docs/architecture.md` | Architecture overview, component diagram, data flow, deployment topology, assessment | Agent 1 (created), Agent 2 (assessment added) |
| `docs/audit-report.md` | Structured quality/sustainability findings with severity ratings | Agent 3 |
| `docs/improvement-plan.md` | Prioritized, milestone-based improvement roadmap | Agent 5 |

---

## 4. KNOWN INVESTIGATION TARGETS

These are specific issues observed during repository context extraction. Agents must investigate and document these — not assume the descriptions below are complete or final.

### Security
- `SecurityConfig.java`: `/cv/**` is `permitAll()`. Since all CRUD endpoints live under `/cv/nodes/**`, **every write operation is unauthenticated**. The `oauth2-client` dependency and `.anyRequest().authenticated()` catch-all appear vestigial — no actual auth flow is implemented.
- CSRF is globally disabled (`csrf.disable()`).
- `docker-compose.yml` and `k8s/postgresql.yaml` contain hardcoded/placeholder database credentials.

### Stale Code & Documentation
- `CvController.java:94` comment says `// Commands - Delete (soft)` but soft delete was removed in migration V4. The `virtual-cv-api/README.md` endpoint table also says "Soft delete node."
- `virtual-cv-ui/src/data/cv-content.ts` and `src/content/cv-content.md` — investigate whether these fallback data files are still reachable or dead code.

### Architecture
- `App.tsx` (408 lines): single `Flow` component handles state management, API calls, keyboard navigation, deep linking, drag handling, and dialog orchestration. Assess whether this is appropriate for the project's scale or a maintainability risk.
- `App.css` (2,431 lines): monolithic stylesheet with no component scoping, no CSS modules, no naming convention beyond descriptive class names.
- `cv.service.ts`: manual in-memory cache (`cachedData`) with no TTL or invalidation beyond explicit `clearCache()`. Assess correctness.
- `App.tsx:279`: type cast `as unknown as UpdateNodeCommand['attributes']` — potential type safety gap.

### CI/CD
- Frontend CI (`deploy.yml`) runs `npm run build` (which includes `tsc`) but does **not** run `npm run lint`.
- Backend CI (`deploy-api.yml`) does **not** run `./gradlew test`.
- Neither pipeline has a test gate — deployment proceeds regardless of test results.

### Testing
- Backend: only `CvNodeRepositoryTest.java` has meaningful tests. No controller tests, no service tests, no integration tests.
- Frontend: zero test files. No test runner configured. No test dependencies in `package.json`.

---

## 5. AGENT ROLES & RESPONSIBILITIES

### Phase 0: Baseline Verification (all agents, prerequisite)

Before any analysis begins, verify the repository builds and runs:

1. Run `cd virtual-cv-ui && npm install && npm run build`. Record result.
2. Run `cd virtual-cv-ui && npm run lint`. Record result.
3. Run `cd virtual-cv-api && ./gradlew build` (if Docker available) or `./gradlew compileJava`. Record result.
4. If any command fails, document the failure and proceed with analysis — but flag the broken build as a P0 finding.

**Exit criteria:** Build status documented. All agents aware of baseline health.

---

### Agent 1: Repo Cartographer

**Scope:** Map structure, boundaries, execution paths, and data flow. Answer "what exists and how does it connect?"

**Tasks:**
1. Enumerate all packages, their boundaries, and dependency relationships (frontend → API contract → backend).
2. Trace the end-to-end data flow with specific file paths:
   ```
   PostgreSQL → Flyway migrations (V1-V4) → CvNode.java → CvNodeService.java → CvController.java
   → OpenAPI spec (/v3/api-docs) → Orval (orval.config.ts) → generated.ts → cv.service.ts
   → cv.mapper.ts → App.tsx → GraphNode.tsx / InspectorPanel.tsx
   ```
3. Map all configuration surfaces: env files, Spring profiles, K8s manifests, feature flags.
4. Document the API contract surface: all REST endpoints with HTTP methods, paths, request/response types. Cross-reference `CvController.java` against `virtual-cv-api/README.md` against `generated.ts`.
5. Map CI/CD: trigger conditions, build steps, deployment targets, what's tested vs. not.

**Artifacts:**
- Update `CLAUDE.md` § "Monorepo Structure" if any files are missing or changed.
- Create `docs/architecture.md` with: component diagram (text-based), end-to-end data flow, deployment topology, configuration surface map, API contract summary.

**Exit criteria:**
- [ ] Every source file accounted for in the structure map.
- [ ] Data flow traced from database to rendered UI with file paths at each stage.
- [ ] API endpoint table verified against actual controller code.
- [ ] `docs/architecture.md` exists and is internally consistent.

**Hand-off:** "CARTOGRAPHY COMPLETE — `docs/architecture.md` created, `CLAUDE.md` updated. Ready for Architecture Analyst."

---

### Agent 2: Architecture Analyst

**Scope:** Assess design quality, coupling, cohesion, and boundary integrity. Answer "how well is this designed?"

**Depends on:** Agent 1 output.

**Tasks:**

#### Frontend Architecture
1. Assess `App.tsx` as the application shell: how much logic, state, and orchestration lives here vs. in child components and services. Is this a god component or appropriately centralized for the project's scale?
2. Evaluate state management: count `useState` hooks in `Flow`, trace how state flows to children. Is there implicit global state via singletons (`cvService`)? Would this scale if features from the backlog are added?
3. Assess `App.css` (2,431 lines): Is there a naming convention? How coupled is it to component structure? What would the cost be of adding the planned light/dark theme toggle?
4. Evaluate the API integration chain: `generated.ts` → `fetcher.ts` → `cv.service.ts`. Is the abstraction clean? Does the `customFetch` wrapper's response shape (`{ data, status, headers } as T`) match what consumers expect?
5. Check type safety: scan for `as unknown as`, `as any`, non-null assertions (`!`), and `Record<string, unknown>` patterns. Quantify type safety gaps.

#### Backend Architecture
1. Evaluate layering discipline: Does business logic leak from `CvNodeService` into `CvController`? Are DTOs properly separated from domain entities?
2. Assess the command pattern: 7 `Create*Command` classes + 1 `UpdateNodeCommand`. Is this warranted for 5 node types, or is it ceremony without benefit?
3. Evaluate the database design: single `cv_node` table with JSONB `attributes` column. What are the query, validation, and migration trade-offs of this schema-per-type-in-JSONB approach?
4. Assess security posture: characterize the actual authentication model (not what dependencies suggest, but what the code enforces). Classify whether this is a conscious choice or an oversight.

#### Vision vs. Reality
1. Compare `docs/initial-roadmap.md` target state against current implementation. Specifically:
   - Planned but not built: CLI client, Edge model, media/S3 storage, guided tour mode, light/dark theme, breadcrumb navigation.
   - Built but not planned: Feature flag system, drag-to-position, deep linking via URL hash, toast notifications.
   - Changed from plan: Auth model (planned JWT/basic auth → currently no auth), persistence (planned Edge entity → flat node-only model), admin (planned separate admin interface → integrated edit mode).
2. Assess whether the divergences are intentional simplifications or gaps that will cause problems as backlog items are implemented.

**Artifacts:**
- Add "Architecture Assessment" section to `docs/architecture.md` with: strengths, concerns, vision-vs-reality summary. Every concern must cite specific file paths and line numbers.

**Exit criteria:**
- [ ] Frontend and backend architecture assessed with evidence.
- [ ] Vision-vs-reality drift documented with specific planned-vs-actual comparisons.
- [ ] All concerns include file paths and are actionable.

**Hand-off:** "ARCHITECTURE ANALYSIS COMPLETE — Assessment added to `docs/architecture.md`. Ready for Quality Auditor."

---

### Agent 3: Quality & Sustainability Auditor

**Scope:** Measure maintainability, test health, operational readiness, and security baseline. Answer "how healthy is this codebase?"

**May run in parallel with:** Agent 2 (no dependency on each other, only on Agent 1).

**Tasks:**

#### 3a. Maintainability
1. Run `npm run lint` and `npm run build` in `virtual-cv-ui/`. Record all warnings and errors verbatim.
2. Run `./gradlew build` in `virtual-cv-api/`. Record compilation warnings.
3. Identify files exceeding 300 lines. For each, note the line count and primary responsibility.
4. Search for dead code: unused exports, unreachable branches, commented-out code blocks, stale imports.
5. Check dependency health: run `npm audit` for frontend. Check Spring Boot version against known CVEs.

#### 3b. Test Health
1. Run `./gradlew test` in `virtual-cv-api/`. Record pass/fail counts and test names.
2. Inventory what is tested vs. what is not:
   - Tested: `CvNodeRepository` (Testcontainers)
   - Not tested: `CvNodeService`, `CvController`, error handling, validation, all frontend code.
3. Assess existing test quality: Do repository tests verify behavior or just "it runs"?
4. For the frontend, note the absence of any test infrastructure (no test runner, no test dependencies, no test files).

#### 3c. CI/CD Health
1. Confirm: frontend CI does NOT run lint. Backend CI does NOT run tests. Document this with workflow file paths and line numbers.
2. Assess deployment safety: What prevents broken code from reaching production?
3. Review Docker build (`virtual-cv-api/Dockerfile`): multi-stage? non-root user? secret leakage?

#### 3d. Security Baseline
1. Confirm and characterize the authentication gap: All endpoints under `/cv/**` are `permitAll()` in `SecurityConfig.java:20`. All CRUD operations (POST, PUT, DELETE) are under `/cv/nodes/**`. This means the API has **no authentication for write operations**.
2. Classify this as intentional (portfolio project, no sensitive data) or as a risk (anyone can modify CV content in production).
3. CORS assessment: `CorsConfig.java` allows 3 specific origins + `allowCredentials(true)`. Is `allowedHeaders("*")` too broad?
4. Check for credentials in version control: `docker-compose.yml`, K8s manifests, `.env` files, `application-*.properties`.
5. Assess input validation: The controller uses `@Valid` annotations — check whether the command classes actually define validation constraints.

#### 3e. Operational Readiness
1. Is Spring Boot Actuator configured beyond the default? Check `application-*.properties` for actuator settings.
2. Is there structured logging, or just default Spring Boot console output?
3. PostgreSQL backup strategy: currently noted as missing in `docs/backlog.md`. Confirm.

**Artifacts:**
- Create `docs/audit-report.md` with findings organized by category. Each finding must include:
  - **ID**: sequential (e.g., `MAINT-01`, `TEST-01`, `SEC-01`)
  - **Severity**: Critical / High / Medium / Low
  - **File(s)**: specific paths and line numbers
  - **Description**: what the issue is
  - **Impact**: what could go wrong
  - **Recommendation**: what to do about it
- Append critical and high findings to `docs/backlog.md` under a new "## Technical Debt" section, preserving existing structure.

**Exit criteria:**
- [ ] All build/lint/test commands executed and results recorded.
- [ ] Every finding has a severity, file path, and recommendation.
- [ ] `docs/audit-report.md` exists with all findings.
- [ ] `docs/backlog.md` updated with critical/high items.

**Hand-off:** "QUALITY AUDIT COMPLETE — Report at `docs/audit-report.md`, backlog updated. Ready for Documentation Steward."

---

### Agent 4: Documentation Steward

**Scope:** Update all documentation to accurately reflect current state. Ensure cross-document consistency.

**Depends on:** Agents 1–3 output.

**Tasks:**

1. **Root `README.md`** — Rewrite from the 2-line stub into a proper project README:
   - Project name, one-line description, link to live URL
   - Architecture overview (brief, reference `docs/architecture.md` for details)
   - Quick start: how to run frontend and backend locally (5 commands max)
   - Tech stack summary (table)
   - Links to: `CLAUDE.md`, `docs/backlog.md`, `docs/architecture.md`, `k8s/README.md`
   - Do NOT add placeholder screenshot sections — only include content that exists now.

2. **`CLAUDE.md`** — Update with:
   - Any new files or structural changes found by Agent 1.
   - Corrected information (e.g., if endpoints changed, if features were added/removed).
   - Keep the existing structure. Do not expand it beyond ~200 lines.

3. **`virtual-cv-ui/README.md`** — Replace boilerplate with:
   - Component inventory with one-line descriptions (match the 11 components in `src/components/`).
   - Service layer overview (4 services).
   - State management approach (describe how `App.tsx` manages state via hooks + service singleton).
   - Styling approach (single `App.css`, no CSS modules, dark theme conventions).
   - Development commands.

4. **`virtual-cv-api/README.md`** — Fix known inaccuracies:
   - Line 61: change "Soft delete node" to "Delete node (hard delete with cascade)".
   - Line 94 of `CvController.java`: note the stale "soft" comment for Agent 6 to fix.
   - Verify all endpoints match `CvController.java` exactly. Add any missing ones.

5. **Cross-document consistency check:** Verify agreement across all docs on:
   - Tech stack versions (React 19, Spring Boot 3.5.10, Java 21, Node 22, PostgreSQL 16)
   - Available commands (must match actual `package.json` scripts and `build.gradle` tasks)
   - Feature completeness status
   - Architecture descriptions

**Artifacts:**
- Updated files: `README.md`, `CLAUDE.md`, `virtual-cv-ui/README.md`, `virtual-cv-api/README.md`.
- Each updated file must have accurate content as of the assessment date.

**Exit criteria:**
- [ ] Root `README.md` has >20 lines of meaningful content.
- [ ] No document references a command or file that doesn't exist.
- [ ] No contradictions between documents.
- [ ] "Soft delete" references corrected everywhere.

**Hand-off:** "DOCUMENTATION UPDATED — All docs reflect current state. Ready for Improvement Planner."

---

### Agent 5: Improvement Planner

**Scope:** Synthesize all findings into a realistic, risk-aware, incremental improvement roadmap.

**Depends on:** Agents 1–4 output.

**Tasks:**

1. Read `docs/audit-report.md`, `docs/architecture.md` (assessment section), and `docs/backlog.md`.
2. Cross-reference quality findings against the product roadmap. Identify which technical improvements **unblock** or **de-risk** planned product features (e.g., test infrastructure unblocks safe implementation of viewer modes).
3. Produce a prioritized plan using this framework:

   | Priority | Criteria | Examples |
   |----------|----------|---------|
   | **P0 — Critical** | Security vulnerabilities, data loss risk, broken CI, build failures | Unauthenticated write API, no tests in CI |
   | **P1 — High** | Missing test infrastructure, operational blind spots, blocking tech debt | No frontend tests, no controller tests, no lint in CI |
   | **P2 — Medium** | Maintainability, developer experience, architectural improvements | App.tsx decomposition, CSS modularization, dead code removal |
   | **P3 — Low** | Polish, optimization, standards alignment | Stale comments, minor type safety fixes, documentation refinements |

4. For each improvement item, specify:
   - **ID**: matching audit report ID where applicable (e.g., `SEC-01`)
   - **Title**: concise action-oriented name
   - **Priority**: P0–P3
   - **Effort**: S (< 1 hour), M (1–4 hours), L (4+ hours)
   - **Risk if deferred**: what could go wrong if this isn't done
   - **Risk if done wrong**: what could break during implementation
   - **Acceptance criteria**: specific, verifiable conditions (build passes, test count, etc.)
   - **Dependencies**: what must be done first
   - **Files affected**: specific paths

5. Group items into **milestones**. Each milestone must:
   - Be deployable — the codebase works after completing it.
   - Be testable — you can verify the milestone is done.
   - Contain no more than 5 items.
   - Have a clear theme (e.g., "CI/CD hardening", "test foundation", "security baseline").

6. **Respect the product backlog.** The improvement plan complements `docs/backlog.md`, not replaces it. P0/P1 items should precede product features; P2/P3 items can be interleaved.

7. **Calibrate to project scale.** This is a single-developer portfolio project with ~30 source files. Recommendations must be proportionate:
   - YES: Add Vitest + a few critical tests. Add lint/test to CI.
   - NO: Implement a full design system. Add Storybook. Set up code coverage thresholds. Adopt a state management library.

**Artifacts:**
- Create `docs/improvement-plan.md` with milestones and items.
- Update `docs/backlog.md` to reference the improvement plan under the "Technical Debt" section (created by Agent 3).

**Exit criteria:**
- [ ] Every item from `docs/audit-report.md` rated Critical or High is addressed in the plan.
- [ ] Every milestone is self-contained and deployable.
- [ ] No recommendation exceeds the complexity appropriate for a small portfolio project.
- [ ] Plan references specific file paths, not abstract concepts.

**Hand-off:** "IMPROVEMENT PLAN COMPLETE — Plan at `docs/improvement-plan.md`. Ready for Implementation Agent."

---

### Agent 6: Implementation Agent

**Scope:** Execute improvement plan milestones incrementally, starting with P0 items.

**Depends on:** Agent 5 output.

**Constraints:**
- **Tests first.** Do not modify production code without verifying test coverage exists for the affected path. If it doesn't, write the test first.
- **One milestone at a time.** Fully complete a milestone before starting the next.
- **Build must pass.** After every change: `npm run build` (frontend), `./gradlew build` (backend).
- **Lint must pass.** After frontend changes: `npm run lint`.
- **No feature work.** Quality, testing, CI, and infrastructure only. Product features (viewer modes, exports) are out of scope.
- **Small, atomic changes.** Each logical change is a separate commit.
- **Conventional commits.** Use prefixes: `fix:`, `test:`, `ci:`, `docs:`, `refactor:`, `chore:`.
- **No breaking API changes.** The OpenAPI contract must remain backward-compatible. If the generated client needs regeneration, do it explicitly via `npm run generate-api`.
- **Do not edit `generated.ts` manually.** Ever.
- **Branch strategy.** Work on a branch named `improvement/<milestone-name>`. Do not push directly to `main`.

**Rollback protocol:** If a change breaks the build or existing tests:
1. Revert the change (`git revert`).
2. Document what went wrong.
3. Re-approach with a smaller scope.
4. Do NOT force the original approach.

**For each change:**
1. State what you're changing and why (reference the improvement plan item ID).
2. Write or verify relevant tests.
3. Make the change.
4. Run the full verification suite (`npm run build && npm run lint` and/or `./gradlew build`).
5. Commit with a descriptive message.
6. Report the result.

**After each milestone:**
- Update `docs/improvement-plan.md`: mark completed items, note any deviations.
- Update `docs/audit-report.md`: mark resolved findings.

**Exit criteria per milestone:**
- [ ] All items in the milestone are completed or explicitly deferred with justification.
- [ ] Build passes for both packages.
- [ ] All existing tests still pass.
- [ ] Any new tests pass.
- [ ] Changes committed on the improvement branch with clean history.

**Hand-off:** "MILESTONE [N] COMPLETE — [X] items resolved, [Y] tests added. Build and tests passing. Branch: `improvement/<name>`."

---

## 6. COORDINATION PROTOCOL

### Execution Order

```
Phase 0 (Baseline) → Agent 1 (Cartographer) → [Agent 2 (Architecture) ‖ Agent 3 (Audit)] → Agent 4 (Docs) → Agent 5 (Planner) → Agent 6 (Implementation)
```

- Agents 2 and 3 **may run in parallel** — they have no dependency on each other, only on Agent 1.
- Agent 4 depends on Agents 2 AND 3.
- Agents 5 and 6 are strictly sequential.

### Shared Artifacts

| Artifact | Status | Created By | Updated By |
|----------|--------|-----------|------------|
| `CLAUDE.md` | EXISTS | — | Agent 1, Agent 4 |
| `docs/backlog.md` | EXISTS | — | Agent 3, Agent 4, Agent 5 |
| `docs/initial-roadmap.md` | EXISTS | — | **Nobody (read-only)** |
| `README.md` (root) | EXISTS (stub) | — | Agent 4 |
| `virtual-cv-api/README.md` | EXISTS | — | Agent 4 |
| `virtual-cv-ui/README.md` | EXISTS | — | Agent 4 |
| `k8s/README.md` | EXISTS | — | Agent 4 (if needed) |
| `docs/architecture.md` | NEW | Agent 1 | Agent 2, Agent 4 |
| `docs/audit-report.md` | NEW | Agent 3 | Agent 6 |
| `docs/improvement-plan.md` | NEW | Agent 5 | Agent 6 |

### Communication Rules

1. **Evidence over opinion.** Every finding must cite file paths and line numbers. "The controller lacks validation" is insufficient. "`CvController.java:44` — `search` endpoint accepts `@RequestParam String q` without `@Valid` or length constraints" is correct.
2. **Reference, don't duplicate.** If a finding is in `docs/audit-report.md`, reference its ID in `docs/improvement-plan.md`. Don't restate it.
3. **Append, don't overwrite.** When updating shared artifacts, add sections. Don't delete previous agents' work unless correcting a factual error (and note the correction).
4. **Use consistent identifiers.** When referring to files, always use paths relative to repository root (e.g., `virtual-cv-ui/src/App.tsx:279`, not `App.tsx` or `/Users/.../App.tsx`).

### Conflict Resolution

If a later agent disagrees with an earlier agent's finding:
1. Add a "Note" to the relevant section of the shared artifact.
2. State the disagreement, the evidence, and the recommended resolution.
3. Do not silently overwrite the earlier finding.

### Verification Checkpoints

Before each hand-off, the completing agent must confirm:
- [ ] All file paths referenced in artifacts are valid.
- [ ] All commands listed in artifacts work when executed.
- [ ] No contradictions introduced between documents.
- [ ] The codebase still builds after any modifications.

---

## 7. WHAT NOT TO DO

- **Do not recommend enterprise-grade solutions.** No design systems, Storybook, full observability stacks, or state management libraries. This is a ~30-file portfolio project.
- **Do not rewrite working code for style.** If code works and is readable, leave it alone. Only flag genuine maintainability risks.
- **Do not add features.** Viewer modes, exports, themes — these are product work in `docs/backlog.md`. This mission handles quality infrastructure only.
- **Do not create documentation that duplicates existing docs.** If the information belongs in `CLAUDE.md`, put it there — don't create `docs/project-overview.md`.
- **Do not modify `generated.ts`.** Ever.
- **Do not modify `docs/initial-roadmap.md`.** Ever.
- **Do not add dependencies without justification.** Each new dependency must be justified in the improvement plan with rationale and alternatives considered.
- **Do not reorganize the repo structure.** The current layout is intentional and documented in `CLAUDE.md`.

---

## 8. MISSION COMPLETION

The mission is complete when:
1. `docs/architecture.md` exists with structure map and quality assessment.
2. `docs/audit-report.md` exists with categorized, evidence-based findings.
3. `docs/improvement-plan.md` exists with prioritized, milestone-based roadmap.
4. All existing documentation is updated, accurate, and internally consistent.
5. At least Milestone 1 (P0 items) of the improvement plan is implemented on a branch.
6. All builds pass. All tests pass.

Report final status as: "MISSION COMPLETE — [summary of what was done, what was deferred, and what the owner should review]."
